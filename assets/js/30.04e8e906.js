(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{384:function(n,t,s){"use strict";s.r(t);var a=s(45),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[n._v("#")]),n._v(" class")]),n._v(" "),s("p",[n._v("class作为ES6的function 语法糖，默认带有一个constructor() 构造函数")]),n._v(" "),s("p",[n._v("class student{\n//没有的话会自动默认生成 constructor(){}\nconstructor(name,age){\nthis.name=name\nthis.age=age\n}\nintroduce(){\nrenturn "),s("code",[n._v("name is ${this.name},age is ${this.age}")]),n._v("\n}\n}\n//new一下class\nconst instance=new student('nuno',24)\nconsole.log(instance)\n//student{\nname:'nuno',\nage:24"),s("br"),n._v("\n}\nconsole.log(instance.introduce())\n//name is nuno,age is 24")]),n._v(" "),s("h2",{attrs:{id:"关于class的继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于class的继承"}},[n._v("#")]),n._v(" 关于class的继承")]),n._v(" "),s("p",[n._v("class people extends student{")]),n._v(" "),s("p",[n._v("//子项也需要有constuctor函数，且需在构造函数内调用super(),来调用继承的\n//父项中的constructor函数")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("    constroctor(name,age,hobby){\n        super(name,age)\n        this.hobby=hobby\n    }\n")])])]),s("p",[n._v("}")]),n._v(" "),s("p",[n._v("const action=new prople('nuno',24,'football')\nconsole.log(action)\n//输出\npeople{\nname:'nuno',\nage:24,\nhobby:'football'\n}\nconsole.log(action.introduce())\n//name is nuno,age is 24")]),n._v(" "),s("h2",{attrs:{id:"关于call、apply的调用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于call、apply的调用方法"}},[n._v("#")]),n._v(" 关于call、apply的调用方法")]),n._v(" "),s("p",[n._v("使用call、apply改变原函数内部的this指向")]),n._v(" "),s("p",[n._v("const obj={\nname:'nuno',\nage:24\n}")]),n._v(" "),s("p",[n._v("function student (a,b){\nconsole.log(this)\nconsole.log(a+b)\n}\nstudent.call(obj,1,2)\nconsole=> {\nname:'nuno',\nage:24\n} , 3\n//call方法将student的内部this指向obj，student函数内部的this即为obj对象")]),n._v(" "),s("h3",{attrs:{id:"用来继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用来继承"}},[n._v("#")]),n._v(" 用来继承")]),n._v(" "),s("p",[n._v("function father(a,b,c){\nthis.a=a\nthis.b=b\nthis.c=c\n}\nfunction son(){\nfather.call(this,1,2,3)\n}\nconsole.log(new son())=> son{\na=1,\nb:2,\nc:3\n}")]),n._v(" "),s("h2",{attrs:{id:"bind的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bind的区别"}},[n._v("#")]),n._v(" bind的区别")]),n._v(" "),s("p",[n._v("都是改变this指向，bind的返回仍是一个函数，不会立即执行该函数。\nthis.$functionName()=fn.bind(this,1,2)\n也可以 fn.bind(this,1,2)()来调用,\n而apply和call是立即执行函数。")])])}),[],!1,null,null,null);t.default=e.exports}}]);